# Architecture

Syntax highlighter that uses **zero DOM nodes** for highlighting. Instead of wrapping tokens in `<span>` elements (like Prism, Shiki, Highlight.js), it renders a tiny pixel image and applies it as the `background-image` of a `<textarea>`. 1 pixel = 1 character, each line of code = 1 pixel row, scaled to match the text using `ch`/`em` units and `image-rendering: pixelated`.

This gives you zero DOM overhead (one image swap instead of thousands of styled spans), native editing for free (cursor, selection, copy/paste, undo/redo, IME, accessibility), tiny payloads (a few KB, no CSS for token colors), and SSR potential (read-only code blocks need zero JS).

The approach is limited to monospace fonts, color-only highlighting (no bold/italic), and has no word wrap or per-token interaction (hover, tooltips) out of the box. Best suited for read-only code display and lightweight editable code blocks — maybe not a replacement for full code editors.

## The CSS Trick

The `<textarea>` has these critical styles:

- **`bg-clip-text`** — background is clipped to the text shape
- **`text-transparent`** — actual text is invisible, background shows through
- **`image-rendering: pixelated`** — keeps the tiny image sharp when scaled
- **`contain: strict`** — isolates element from browser layout recalculations
- **`will-change: background-image, background-size`** — hints GPU compositing
- **`caret-white`** — cursor remains visible despite transparent text

## Pipeline

Tokens are generated by an external library (Prism.js) and mapped to RGBA colors via a theme. The token data is written into an `ImageData` pixel buffer and transferred to a canvas.

The canvas image must be **preloaded through an `<img>` element** before it is applied as the textarea's background-image. Without this, the browser shows a flash of white text between updates because the new data URL hasn't been decoded yet. The old background stays visible until `img.onload` confirms the new image is ready.

```
Input Event
  → queueMicrotask (batch rapid keystrokes)
    → tokenize → pixel buffer → canvas → toDataURL()
    → img.src = dataURL
      → img.onload (new image decoded and ready)
        → requestAnimationFrame
          → swap background-image on textarea
```

## Design Decisions

- **No overlay `<div>`, no virtual DOM** — just a textarea with a background image
- **`toDataURL()` over `toBlob()`** — synchronous, simpler, and the images are tiny (a few KB). The async overhead of `toBlob()` adds latency and complexity without measurable benefit at this scale
- **RGBA tuples in theme** — hex strings are parsed once at startup, not on every render

## Potential Next Steps

- **OffscreenCanvas + Worker** — move tokenization and rendering off the main thread
- **Incremental tokenization** — only re-tokenize changed lines instead of the full source
- **`Uint32Array` view on ImageData** — write one 32-bit value per pixel instead of four 8-bit writes
- **Word wrap support** — currently the background image is one fixed row per line. If the textarea wraps text, the visible text and the background go out of sync. Would need to account for the textarea's width and reflow tokens into multiple pixel rows per logical line
- **Server-side rendering** — generate the pixel image on the server so the first paint already has syntax highlighting without waiting for JS. For read-only code blocks, this means zero JS needed — just a `<pre>` with a background image
